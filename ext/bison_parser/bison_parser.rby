
%token IDENTIFIER
%token STRING
%token COLON
%token SEMICOLON
%token LBRACK
%token RBRACK
%token PIPE
%token HASH
%token DOUBLE_HASH
%token KW_TOKEN
%token ACTIONS

%%

grammar_file :
  token_list[tokens] DOUBLE_HASH grammar_rules[rules] optional_code[code]
  { self.result = Bison::GrammarFile.new(tokens, rules, code) }
;

optional_code :
  { nil }
|
  DOUBLE_HASH ACTIONS[actions]
  { actions }
;

token_list :
  { [] }
|
  token_list[list]
  HASH KW_TOKEN IDENTIFIER[name]
  { list << name }
;

grammar_rules:
  { [] }
|
  grammar_rules[list] grammar_rule[rule]
  { list << rule }
;

grammar_rule:
  IDENTIFIER[name] COLON components[components] SEMICOLON
  { Bison::Rule.new(name, components) }
;

components:
  { [] }
| component[component]
  { [component] }
|
  components[sequence] PIPE component[component]
  { sequence << component }
;


component:
  sequence
|
  sequence[sequence] ACTIONS[action]
  { sequence.tap do |s|; s.action = action; end }
;

sequence:
  { Bison::Sequence.new }
|
  sequence[sequence] IDENTIFIER[follower]
  { sequence << Bison::Nonterminal.new(follower) }
|
  sequence[sequence] IDENTIFIER[follower] LBRACK IDENTIFIER[tag] RBRACK
  { sequence << Bison::Nonterminal.new(follower, tag) }
;

%%

class BisonParser
  attr_accessor :section

  def error(msg, row, col)
    abort("#{row}.#{col}: #{msg}")
  end

  def lex
    self.section ||= 0
    self.lex_value = nil

    if section == 2
      self.lex_value = io.read
      self.section += 2
      return Tokens::ACTIONS
    end

    # skip space
    while (c = io.read(1)) && c =~ /\s/
      if c == "\n"
        self.row += 1
        self.col = 0
      else
        self.col += 1
      end
    end
    
    return nil unless c

    peak = io.read(1)
    io.ungetc(peak) if peak

    case c
    when ':'
      return Tokens::COLON
    when ';'
      return Tokens::SEMICOLON
    when '|'
      return Tokens::PIPE
    when '%'
      if peak == '%'
        io.read(1)
        self.col += 1
        self.section += 1
        return Tokens::DOUBLE_HASH
      end
      return Tokens::HASH
    when '['
      return Tokens::LBRACK
    when ']'
      return Tokens::RBRACK
    when '{'
      action = ''
      while (c = io.read(1))
        break if c == '}'
        action << c
        if c == "\n"
          self.row += 1
          self.col = 0
        else
          self.col += 1
        end
      end
      self.lex_value = action
      return Tokens::ACTIONS
    end

    if c =~ /\w/
      string = c
      while (c = io.read(1)) && c =~ /\w/
        string << c
        self.col += 1
      end

      io.ungetc(c) if c

      case string
      when 'token'
        return Tokens::KW_TOKEN
      else
        self.lex_value = string
        return Tokens::IDENTIFIER
      end
    end

    return nil
  end
end